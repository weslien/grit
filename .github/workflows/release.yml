name: Release

on:
  push:
    tags:
      - 'v*'

env:
  GO_VERSION: '1.24'

permissions:
  contents: write
  packages: write

jobs:
  # Create GitHub release with release notes
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    outputs:
      tag_name: ${{ steps.get_tag.outputs.tag_name }}
      release_id: ${{ steps.create_release.outputs.id }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get tag name
      id: get_tag
      run: echo "tag_name=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

    - name: Generate changelog
      id: changelog
      run: |
        # Get the previous tag
        PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
        
        # Generate changelog
        echo "## Changes in ${{ steps.get_tag.outputs.tag_name }}" > CHANGELOG.md
        echo "" >> CHANGELOG.md
        
        if [ -n "$PREV_TAG" ]; then
          echo "### Commits since $PREV_TAG:" >> CHANGELOG.md
          git log --oneline --no-merges $PREV_TAG..HEAD >> CHANGELOG.md
        else
          echo "### All commits:" >> CHANGELOG.md
          git log --oneline --no-merges >> CHANGELOG.md
        fi
        
        echo "" >> CHANGELOG.md
        echo "### Full Changelog" >> CHANGELOG.md
        echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/$PREV_TAG...${{ steps.get_tag.outputs.tag_name }}" >> CHANGELOG.md

    - name: Create Release
      id: create_release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ steps.get_tag.outputs.tag_name }}
        name: Release ${{ steps.get_tag.outputs.tag_name }}
        body_path: CHANGELOG.md
        draft: false
        prerelease: ${{ contains(steps.get_tag.outputs.tag_name, '-') }}
        generate_release_notes: true

  # Build and upload release binaries
  build-and-upload:
    name: Build and Upload
    needs: create-release
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - goos: linux
            goarch: amd64
            asset_name: grit-linux-amd64
          - goos: linux
            goarch: arm64
            asset_name: grit-linux-arm64
          - goos: darwin
            goarch: amd64
            asset_name: grit-darwin-amd64
          - goos: darwin
            goarch: arm64
            asset_name: grit-darwin-arm64
          - goos: windows
            goarch: amd64
            asset_name: grit-windows-amd64.exe
          - goos: freebsd
            goarch: amd64
            asset_name: grit-freebsd-amd64

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Download dependencies
      run: go mod download

    - name: Build binary
      env:
        GOOS: ${{ matrix.goos }}
        GOARCH: ${{ matrix.goarch }}
        CGO_ENABLED: 0
      run: |
        echo "ðŸ”¨ Building ${{ matrix.asset_name }} for ${{ matrix.goos }}/${{ matrix.goarch }}"
        mkdir -p dist
        
        # Build with version information
        go build -v \
          -ldflags="-s -w -X 'main.version=${{ needs.create-release.outputs.tag_name }}' -X 'main.commit=${{ github.sha }}' -X 'main.date=$(date -u +%Y-%m-%dT%H:%M:%SZ)'" \
          -o dist/${{ matrix.asset_name }} ./main.go
        
        # Verify the binary was created and works
        if [ -f "dist/${{ matrix.asset_name }}" ]; then
          echo "âœ… Successfully built dist/${{ matrix.asset_name }}"
          # Test the binary (skip for cross-compiled binaries that can't run on current platform)
          if [ "${{ matrix.goos }}" = "linux" ] && [ "${{ matrix.goarch }}" = "amd64" ]; then
            chmod +x dist/${{ matrix.asset_name }}
            dist/${{ matrix.asset_name }} --version && echo "âœ… Binary test passed"
          fi
        else
          echo "âŒ Failed to create binary"
          exit 1
        fi

    - name: Create package
      run: |
        cd dist
        
        # Create a directory for packaging
        PACKAGE_NAME="grit-${{ needs.create-release.outputs.tag_name }}-${{ matrix.goos }}-${{ matrix.goarch }}"
        mkdir -p "$PACKAGE_NAME"
        
        # Copy binary
        cp ${{ matrix.asset_name }} "$PACKAGE_NAME/"
        
        # Copy additional files
        cp ../README.md "$PACKAGE_NAME/"
        cp ../IMPROVEMENTS_SUMMARY.md "$PACKAGE_NAME/"
        
        # Create installation script for Unix-like systems
        if [ "${{ matrix.goos }}" != "windows" ]; then
          cat > "$PACKAGE_NAME/install.sh" << EOF
        #!/bin/bash
        set -e
        
        BINARY_NAME="${{ matrix.asset_name }}"
        TARGET_NAME="grit"
        INSTALL_DIR="/usr/local/bin"
        
        echo "Installing Grit monorepo tool..."
        
        # Check if running as root or with sudo
        if [[ \$EUID -eq 0 ]]; then
            cp "\$BINARY_NAME" "\$INSTALL_DIR/\$TARGET_NAME"
            chmod +x "\$INSTALL_DIR/\$TARGET_NAME"
            echo "âœ… Grit installed to \$INSTALL_DIR/\$TARGET_NAME"
            echo "ðŸ’¡ You can now run 'grit --help' to get started"
        else
            echo "âš ï¸  Please run with sudo to install to \$INSTALL_DIR"
            echo "ðŸ’¡ Or copy the binary manually:"
            echo "   sudo cp \$BINARY_NAME \$INSTALL_DIR/\$TARGET_NAME"
            echo "   sudo chmod +x \$INSTALL_DIR/\$TARGET_NAME"
        fi
        EOF
          chmod +x "$PACKAGE_NAME/install.sh"
        fi
        
        # Create archive
        if [ "${{ matrix.goos }}" = "windows" ]; then
          zip -r "${PACKAGE_NAME}.zip" "$PACKAGE_NAME"
          echo "ASSET_PATH=${PACKAGE_NAME}.zip" >> $GITHUB_ENV
          echo "ASSET_CONTENT_TYPE=application/zip" >> $GITHUB_ENV
        else
          tar -czf "${PACKAGE_NAME}.tar.gz" "$PACKAGE_NAME"
          echo "ASSET_PATH=${PACKAGE_NAME}.tar.gz" >> $GITHUB_ENV
          echo "ASSET_CONTENT_TYPE=application/gzip" >> $GITHUB_ENV
        fi

    - name: Upload Release Asset
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.create-release.outputs.tag_name }}
        files: dist/${{ env.ASSET_PATH }}

  # Generate completion scripts and upload as assets
  generate-completions:
    name: Generate Completions
    needs: create-release
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Build grit
      run: |
        echo "ðŸ”¨ Building grit for completion generation..."
        go build -o grit main.go
        chmod +x grit
        echo "âœ… Built grit successfully"

    - name: Generate completion scripts
      run: |
        echo "ðŸ”§ Generating completion scripts..."
        mkdir -p completions
        
        ./grit completion bash > completions/grit.bash && echo "âœ… Generated Bash completion"
        ./grit completion zsh > completions/_grit && echo "âœ… Generated Zsh completion"
        ./grit completion fish > completions/grit.fish && echo "âœ… Generated Fish completion"
        ./grit completion powershell > completions/grit.ps1 && echo "âœ… Generated PowerShell completion"
        
        echo "ðŸ“Š Completion files generated:"
        ls -la completions/
        
        # Create installation instructions
        cat > completions/README.md << 'EOF'
        # Grit Shell Completions
        
        This directory contains shell completion scripts for Grit.
        
        ## Bash
        ```bash
        # For current session
        source grit.bash
        
        # For all sessions (Linux)
        sudo cp grit.bash /etc/bash_completion.d/
        
        # For all sessions (macOS with Homebrew)
        cp grit.bash $(brew --prefix)/etc/bash_completion.d/
        ```
        
        ## Zsh
        ```bash
        # Ensure completions are enabled
        echo "autoload -U compinit; compinit" >> ~/.zshrc
        
        # Install completion
        cp _grit "${fpath[1]}/"
        ```
        
        ## Fish
        ```bash
        # For current session
        source grit.fish
        
        # For all sessions
        cp grit.fish ~/.config/fish/completions/
        ```
        
        ## PowerShell
        ```powershell
        # For current session
        grit.ps1
        
        # For all sessions, add to PowerShell profile
        ```
        EOF
        
        # Create archive
        tar -czf grit-completions-${{ needs.create-release.outputs.tag_name }}.tar.gz completions/

    - name: Upload Completions
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.create-release.outputs.tag_name }}
        files: grit-completions-${{ needs.create-release.outputs.tag_name }}.tar.gz

  # Create Docker image (optional)
  docker:
    name: Build Docker Image
    needs: create-release
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ghcr.io/${{ github.repository }}
        tags: |
          type=ref,event=tag
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=semver,pattern={{major}}

    - name: Create Dockerfile
      run: |
        cat > Dockerfile << 'EOF'
        FROM golang:1.24-alpine AS builder
        
        WORKDIR /app
        COPY go.mod go.sum ./
        RUN go mod download
        
        COPY . .
        RUN CGO_ENABLED=0 GOOS=linux go build -ldflags="-s -w" -o grit main.go
        
        FROM alpine:latest
        RUN apk --no-cache add ca-certificates git
        WORKDIR /root/
        
        COPY --from=builder /app/grit /usr/local/bin/
        
        ENTRYPOINT ["grit"]
        EOF

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        platforms: linux/amd64,linux/arm64